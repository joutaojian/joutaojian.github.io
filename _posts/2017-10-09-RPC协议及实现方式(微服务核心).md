---
title: RPC协议及实现方式(微服务核心)
layout: post
tags:
  - Java
  - 微服务
  - RPC
category: 后台
---
分布式系统的核心在于微服务，微服务的核心在于RPC。

## RPC是什么
> - RPC 的全称是 Remote Procedure Call ，是一种进程间通信方式。
> - 它允许程序调用另一个地址空间的过程或函数，而不用程序员显式编码这个远程调用的细节，程序员无论是调用本地的还是远程的，本质上编写的调用代码基本相同。
> - 说两台服务器A、B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。

`Remote Procedure Call，翻译过来应该是“远程程序调用”，目前业内通用的翻译是“远程过程调用”，但是“过程”这个词很容易造成误解，翻译成“程序”更好理解RPC的意义。`

## RPC协议说了什么
一般所谓的XX协议就是个文档，类似于我们的需求文档，只说了要做什么，但是具体怎么做是由各大开源大佬做的。`一般情况下都会实现核心功能，不同的开源在细节上实现都会不一样，这个需要注意！`

RPC 这个概念术语在上世纪 80 年代由 Bruce Jay Nelson 提出的，在 Nelson 的论文 "Implementing Remote Procedure Calls" 中，他提到了几个`RPC的特点`：
> 1. 简单：RPC 概念的语义十分清晰和简单，这样建立分布式计算就更容易。
> 2. 高效：过程调用看起来十分简单而且高效。
> 3. 通用：在单机计算中过程往往是不同算法部分间最重要的通信机制。

除此之外，这位大佬还给出了实现RPC框架的`详细架构图`：
[![](http://7xkmea.com1.z0.glb.clouddn.com/githubioRPC%E5%8D%8F%E8%AE%AE%E5%8F%8A%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%28%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A0%B8%E5%BF%83%29-1.png)](http://7xkmea.com1.z0.glb.clouddn.com/githubioRPC%E5%8D%8F%E8%AE%AE%E5%8F%8A%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%28%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A0%B8%E5%BF%83%29-1.png)

结合上图，Nelson 的论文中指出实现 RPC 的程序包括 5 个部分：
> 1. User
> 2. User-stub
> 3. RPCRuntime
> 4. Server-stub
> 5. Server

------------

> 1. User 是调用方
> 2. User-stub 负责将调用的接口、方法和参数通过约定的协议规范进行编码
> 3. RPCRuntime 负责将本地数据传输到远端的RPCRuntime
> 4. Server-stub 负责根据约定的协议规范进行解码
> 5. Server 是被调用方

所以这架构图的意思是：当 user 想发起一个远程调用时，它实际是通过本地调用 User-stub。并通过本地的RPCRuntime传输 。远端 RPCRuntime 实例收到请求后交给 Server-stub 进行解码后发起本地端调用，调用结果再返回给 User 端。

## 想想怎么实现RPC协议
看完协议内容，跟着就得实现这个协议啦，这时候你是不是发现了问题的严重性：`自！己！一！点！思！路！都！没！有！`
[![](http://7xkmea.com1.z0.glb.clouddn.com/githubioRPC%E5%8D%8F%E8%AE%AE%E5%8F%8A%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%28%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A0%B8%E5%BF%83%29-2.gif)](http://7xkmea.com1.z0.glb.clouddn.com/githubioRPC%E5%8D%8F%E8%AE%AE%E5%8F%8A%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%28%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A0%B8%E5%BF%83%29-2.gif)

#### 序列化协议和传输协议
所以我们需要再理解一下RPC协议，根据Nelson的论文知道我们要做的两件事：
> 1. 将调用的接口、方法和参数通过约定的协议规范进行编码/解码（User-stub/Server-stub）
> 2. 将本地数据传输到远端(RPCRuntime)

上述两点其实是实现RPC协议的两大要素：**序列化协议和传输协议**。

#### 本地与远程调用的对比
因为RPC本质上是进程间通信，而“本地调用和远程调用的对比”实际上就是“进程内通信和进程间通信的对比”。通过两者的对比，我们才能理解到**序列化协议和传输协议**的作用，如下图：
[![](http://7xkmea.com1.z0.glb.clouddn.com/githubioRPC%E5%8D%8F%E8%AE%AE%E5%8F%8A%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%28%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A0%B8%E5%BF%83%29-4.png)](http://7xkmea.com1.z0.glb.clouddn.com/githubioRPC%E5%8D%8F%E8%AE%AE%E5%8F%8A%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%28%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A0%B8%E5%BF%83%29-4.png)

#### 理解单点式RPC框架和分布式RPC框架的区别
最基本的RPC框架就是**单点式**的，因为A服务直接调用B服务，不经过第三方，这种是最简单的。但是必须是A和B同时部署一套，A1只能调用B1，A2只能调用B2。
> 假设现在B服务出现了性能瓶颈，部署多台B服务的同时，也只能部署多台A服务，很浪费资源。

所以需要一台A服务对多台B服务，利用第三方服务(注册中心)找到其他B服务，而不是写死B服务的地址。这种RPC才是**分布式**RPC，也是业内主流。

* 单点式RPC框架（自己玩自己）：
[![](http://7xkmea.com1.z0.glb.clouddn.com/RPC%E5%8D%8F%E8%AE%AE%E5%8F%8A%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%28%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A0%B8%E5%BF%83%29-6.png)](http://7xkmea.com1.z0.glb.clouddn.com/RPC%E5%8D%8F%E8%AE%AE%E5%8F%8A%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%28%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A0%B8%E5%BF%83%29-6.png)

* 分布式RPC框架(自己玩自己，还能玩别人)：
[![](http://7xkmea.com1.z0.glb.clouddn.com/RPC%E5%8D%8F%E8%AE%AE%E5%8F%8A%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%28%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A0%B8%E5%BF%83%29-5.png)](http://7xkmea.com1.z0.glb.clouddn.com/RPC%E5%8D%8F%E8%AE%AE%E5%8F%8A%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%28%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A0%B8%E5%BF%83%29-5.png)

