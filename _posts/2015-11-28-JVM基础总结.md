---
title:  JVM基础总结
date:   2015-11-28 20:05:00 +0800
categories:
- 后台
tags:
- JVM
- Java
---


## 内存分配

1.OS划分一部分内存给JVM，JVM把自己的内存划分为若干个不同的数据区域

2.运行时数据区：程序计数器，虚拟机栈，本地方法栈，堆，方法区

![img](http://7xkmea.com5.z0.glb.clouddn.com/9JVM内存.png)

3.程序计数器：

JVM的多线程是通过线程轮流切换并分配处理器处理时间的方式实现的，为了让线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程间的计数器互不影响，线程私有。

程序计数器可以看作是当前线程所执行的字节码的行号指示器，字节码解释器工作的时候需要改变这个程序计数器的值来选取下一条指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要计数器完成。

1.4.虚拟机栈

每个方法在执行的同时会创建一个栈帧(一个栈帧代表一个方法)，用于存储局部变量表、操作数栈、动态链接、方法出口等。每个方法从调用到执行完成，就对应着一个栈帧在虚拟机栈中的入栈和出栈

如果线程请求的深度大于栈的深度，会报SO

虚拟机栈扩展时无法申请到足够的内存，会报OOM

4.1局部变量表

存放编译期可知的8种基本数据类型和引用类型，局部变量表所需的内存空间在编译期间完成分配，进入方法时局部变量表的空间大小是固定的，在方法运行时不会改变。

5.本地方法栈

功能与虚拟机栈一样，但是不针对java的方法，只针对Native方法。（执行Native方法使用，就是JNI）

在HotSpot虚拟机中，两者合二为一。

6.堆

是JVM管理的内存中最大的一块。

线程共享，存放对象实例及数组。

堆没有内存完成实例分配，会报OOM。

7.方法区

存储JVM加载的类信息、常量、静态变量、JIT编译后的代码

7.1.运行时常量池

存放编译期生成的常量和引用，不要求常量一定只在编译期产生，可以使用intern将新的常量加到常量池中。

8.直接内存

不在JVM运行时内存区域，但是因为其频繁调用会导致OOM。

NIO使用Native函数库直接分配堆外内存，再用堆中的DirectByteBuffer对象作为直接内存的引用对其进行操作。



## 内存溢出分析

**感谢这篇文章：http://blog.sina.com.cn/s/blog_5736f0910100sm6l.html**

①虚拟机栈和本地方法栈溢出

报错信息：Stackoverflow

解决办法：1.每个线程的栈容量太小了，用-Xss调大点

                2.方法帧太大了（一般都是局部变量表太长了，是不是变量的值太大了）

报错信息：OutOfMemoryError:unable to create new native thread(一般多线程导致的OOM都是栈出了问题)

解决办法：1.新建的线程会分配到一定的栈容量，栈的总容量是不变的，如果每个线程分配的栈容量越大，能够建立的新线程就越少，一旦没有足够内存新建线程，就会发生OOM。

                2.应该减少最大堆容量，空余内存将留给栈

                3.应该减少栈容量，这样可以产生更多的线程

②Java堆溢出

报错信息：Java Heap Space

解决办法：1.通过参数-XX:+HeapDumpOnOutOfMemoryError来Dump堆转储快照进行分析

                2.打开Memory Analyzer来判定是内存泄漏还是内存溢出(就是对象应该死？还是活？)

                3.内存泄漏：对象已死但是没有回收，看看为什么没有回收掉

                  内存溢出：对象应该活着，但是堆空间不够，对象的生命周期太长，对象太多

③方法区和运行时常量池溢出

报错信息：PermGen space(永生代)

解决办法：1.常量池爆了，检查下String吧

                2.class类太多了，一般用框架和第三方的Jar包会遇到，除掉相同的jar包吧

④本机直接内存溢出：

报错信息：OOM(这个有点难发现，如果Dump文件太小，或者提示用到了NIO，那就是这里报错了)

解决办法：无



## 垃圾回收

1.目前内存的动态分配、内存自动回收技术已经相当成熟，为什么去了解GC和内存分配？

答：

    1.排查各种内存溢出、内存泄漏问题；

    2.当垃圾回收成为系统的瓶颈的时候

2.什么内存需要回收？

答：

    1.程序计数器、虚拟机栈、本地方法栈 是线程私有，随着线程生死，线程结束后会自动回收，一般不会有事

    1. 方法区和堆是线程共享的，方法区主要存放类的信息和常量池，堆主要存放对象实例和数组，GC操作重点关注这两块区域

3.什么时候回收内存？

答：(判断是否需要回收)

    1.针对方法区：引用计数法(当计数器为0时代表对象无引用可回收，无法解决循环调用)、可达性分析(当对象与GC roots无连接的时候可回收，解决了循环调用)

    2.针对堆：废弃常量(代码中没有该常量的引用就会被回收)、无用的类(无实例，无加载器，无引用)

4.怎样回收内存？

答：

    1.标记-清除算法(效率低，容易产生垃圾碎片)、复制算法(效率高，把存活的内存Copy出来，所以会冗余内存)、标记-整理算法(效率低，解决了垃圾碎片的问题)

    2.Java堆分为新生代和老年代，新生代有大量对象死去，存活率低；老年代只有少量对象死去，存活率高

    3.新生代存活的对象少，用户复制算法，效率高而且不会浪费太多的内存；老年代存活的对象太多，用标记-清除或者标记-整理算法



## 类加载机制

![img](http://7xkmea.com5.z0.glb.clouddn.com/9jvm结构图.png)

![img](http://7xkmea.com5.z0.glb.clouddn.com/9类的生命周期.jpg)

1.加载：

    1.将类的信息加载到方法区中

2.连接：(验证 及 初始化前准备)

    1.验证：验证类的格式是否标准，保证加载的类能够被JVM运行

    2.准备：类的静态变量分配内存并设为jvm默认的初值(基本类型默认为0，引用为null)，对于非静态的变量不会为它们分配内存

    3.解析：常量池中的符号引用转换为直接引用

3.初始化

    1.初始化static修饰的静态赋值语句和静态语句，而没有static修饰的赋值语句和执行语句在实例化对象的时候才会运行。

    2.类的初始化之后，根据方法区中类的信息，在堆中实例化对象，初始化非静态语句和构造方法

    3.静态、非静态、构造函数的执行顺序：

        1-->父类静态方法 
        2-->子类静态方法 
        3-->父类非静态方法 
        4-->父类构造方法 
        5-->子类非静态方法 
        6-->子类构造方法

4.使用

    1.对象操作：从对象中获取信息、改变对象的状态、使对象执行某些操作

    2.实现途径：引用对象变量、调用对象方法

5.卸载

    1.回收类之前将调用finalize清除类的实例

    2.回收类 满足3个条件：无实例、无加载、无引用